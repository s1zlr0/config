import tkinter as tk
from tkinter import scrolledtext
import os
import sys
import platform
import argparse
import time


class ShellEmulator:
    def __init__(self, root, vfs_path=None, startup_script=None):
        self.root = root
        self.current_dir = os.getcwd()
        self.vfs_path = vfs_path or os.path.join(os.getcwd(), "vfs_root")
        self.startup_script = startup_script

        os.makedirs(self.vfs_path, exist_ok=True)

        username = os.getenv('USERNAME') or os.getenv('USER') or 'user'
        hostname = platform.node()

        self.root.title(f"Эмулятор VFS - [{username}@{hostname}]")
        self.root.geometry("800x600")

        self.output_area = scrolledtext.ScrolledText(
            root,
            wrap=tk.WORD,
            bg='black',
            fg='white',
            insertbackground='white',
            font=('Courier New', 10)
        )
        self.output_area.pack(expand=True, fill='both', padx=5, pady=5)
        self.output_area.config(state=tk.DISABLED)

        input_frame = tk.Frame(root)
        input_frame.pack(fill=tk.X, padx=5, pady=5)

        self.prompt_label = tk.Label(
            input_frame,
            text=f"VFS [{username}@{hostname}] $ ",
            bg='black',
            fg='green',
            font=('Courier New', 10)
        )
        self.prompt_label.pack(side=tk.LEFT)

        self.input_entry = tk.Entry(
            input_frame,
            bg='black',
            fg='white',
            insertbackground='white',
            font=('Courier New', 10)
        )
        self.input_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.input_entry.bind('<Return>', self.execute_command)
        self.input_entry.focus()

        self.print_output("=== ДЕБАГ ИНФОРМАЦИЯ ===\n")
        self.print_output(f"VFS путь: {self.vfs_path}\n")
        self.print_output(f"Стартовый скрипт: {self.startup_script}\n")
        self.print_output("=======================\n\n")

        if self.startup_script and os.path.exists(self.startup_script):
            self.print_output(f"Запуск стартового скрипта: {self.startup_script}\n")
            self.execute_script(self.startup_script)
        else:
            self.print_output("Добро пожаловать в эмулятор VFS!\n")
            self.print_output("Команды: ls, cd, exit\n")

    def execute_script(self, script_path):
        try:
            with open(script_path, 'r', encoding='utf-8') as file:
                lines = file.readlines()

            for line in lines:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                self.print_output(f"$ {line}\n")
                self.root.update()
                time.sleep(0.5)

                command, args = self.parse_command(line)
                self.process_command(command, args)

        except Exception as e:
            self.print_output(f"Ошибка выполнения скрипта: {e}\n")

    def print_output(self, text):
        self.output_area.config(state=tk.NORMAL)
        self.output_area.insert(tk.END, text)
        self.output_area.see(tk.END)
        self.output_area.config(state=tk.DISABLED)
        self.root.update()

    def parse_command(self, command_string):
        parts = command_string.strip().split()
        if not parts:
            return "", []
        command = parts[0]
        args = parts[1:]
        return command, args

    def process_command(self, command, args):
        if not command:
            return

        if command == "exit":
            self.cmd_exit(args)
        elif command == "ls":
            self.cmd_ls(args)
        elif command == "cd":
            self.cmd_cd(args)
        else:
            self.print_output(f"Ошибка: неизвестная команда '{command}'\n")

    def execute_command(self, event):
        command_string = self.input_entry.get().strip()
        self.input_entry.delete(0, tk.END)

        self.print_output(f"$ {command_string}\n")

        command, args = self.parse_command(command_string)
        self.process_command(command, args)

    def cmd_exit(self, args):
        self.print_output("Выход из эмулятора VFS...\n")
        self.root.quit()

    def cmd_ls(self, args):
        self.print_output("Команда: ls\n")
        if args:
            self.print_output(f"Аргументы: {args}\n")
        else:
            self.print_output("Аргументы: отсутствуют\n")
        self.print_output("(заглушка) Содержимое текущей директории VFS\n")

    def cmd_cd(self, args):
        self.print_output("Команда: cd\n")
        if args:
            self.print_output(f"Аргументы: {args}\n")
            if len(args) > 1:
                self.print_output("Ошибка: слишком много аргументов для команды 'cd'\n")
            else:
                self.print_output(f"(заглушка) Смена директории VFS на: {args[0]}\n")
        else:
            self.print_output("Аргументы: отсутствуют\n")
            self.print_output("(заглушка) Возврат в домашнюю директорию VFS\n")


def parse_arguments():
    parser = argparse.ArgumentParser(description='Эмулятор командной строки VFS')
    parser.add_argument('--vfs-path', type=str, help='Путь к физическому расположению VFS')
    parser.add_argument('--startup-script', type=str, help='Путь к стартовому скрипту')
    return parser.parse_args()


def run_emulator():
    args = parse_arguments()
    root = tk.Tk()
    app = ShellEmulator(root, args.vfs_path, args.startup_script)
    root.mainloop()


if __name__ == "__main__":
    run_emulator()
